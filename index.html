<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Alien Space Movement</title>
<style>
body {
margin: 0;
overflow: hidden;
background: black;
}

canvas {
display: block;
}
</style>
</head>
<body>
<canvas id="painting"></canvas>

<script>
const canvas = document.getElementById('painting');
const ctx = canvas.getContext('2d');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const shapes = [];

function randomColor() {
return `rgba(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.random().toFixed(1)})`;
}

function createShape() {
return {
x: Math.random() * canvas.width,
y: Math.random() * canvas.height,
size: Math.random() * 200 + 50,
depth: Math.random() * 5 + 1, // Depth factor to simulate z-axis movement
type: Math.floor(Math.random() * 4), // Add more types for complexity
color: randomColor(),
stroke: randomColor(),
lineWidth: Math.random() * 10
};
}

function drawShape(shape) {
ctx.fillStyle = shape.color;
ctx.strokeStyle = shape.stroke;
ctx.lineWidth = shape.lineWidth;

switch (shape.type) {
case 0: // Rectangle
ctx.fillRect(shape.x, shape.y, shape.size, shape.size);
break;
case 1: // Circle
ctx.beginPath();
ctx.arc(shape.x, shape.y, shape.size / 2, 0, Math.PI * 2);
ctx.fill();
ctx.stroke();
break;
case 2: // Line
ctx.beginPath();
ctx.moveTo(shape.x, shape.y);
ctx.lineTo(shape.x + shape.size, shape.y + shape.size);
ctx.stroke();
break;
case 3: // Polygon
ctx.beginPath();
const sides = 3 + Math.floor(Math.random() * 6); // Random polygon with 3-8 sides
const angle = Math.PI * 2 / sides;
for (let i = 0; i < sides; i++) {
ctx.lineTo(
shape.x + Math.cos(angle * i) * shape.size / 2,
shape.y + Math.sin(angle * i) * shape.size / 2
);
}
ctx.closePath();
ctx.fill();
ctx.stroke();
break;
}
}

function updateShapes() {
for (let i = 0; i < shapes.length; i++) {
const shape = shapes[i];
shape.size -= shape.depth; // Decrease size to simulate moving into the screen
shape.x += (Math.random() - 0.5) * shape.depth; // Slight horizontal movement for randomness
shape.y += (Math.random() - 0.5) * shape.depth; // Slight vertical movement for randomness

// Reset shape when it becomes too small
if (shape.size <= 0) {
shapes[i] = createShape();
}
}
}

function loop() {
ctx.clearRect(0, 0, canvas.width, canvas.height);
updateShapes();
shapes.forEach(drawShape);
requestAnimationFrame(loop);
}

// Create initial shapes
for (let i = 0; i < 100; i++) {
shapes.push(createShape());
}

window.addEventListener('resize', () => {
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
});

loop();
</script>
</body>
</html>
